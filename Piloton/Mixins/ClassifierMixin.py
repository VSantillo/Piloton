from typing import TYPE_CHECKING, List, MutableMapping, Tuple, Union

from sklearn import tree
import numpy as np

# Only import when type checking
if TYPE_CHECKING:
    from Piloton.Devices import Bike

    _Base = Bike
else:
    _Base = object


class ClassifierMixin(_Base):  # type: ignore
    def __init__(self):
        """
        Initialize a Decision Tree Classifier used to predict Resistance.
        NOTE: I've never done any "ML" work so, I'm still experimenting with things here.
        """
        self.classifier = tree.DecisionTreeClassifier()
        self.trained: bool = False
        super().__init__()

    def train(self, training_data: MutableMapping[int, MutableMapping[int, List[Tuple[int, float]]]]) -> None:
        """
        Fit the training data to the Decision Tree Classifier

        :param training_data: training_data from Piloton base class
        """
        # Set up our data structures
        classifications: List[int] = []
        training_inputs: List[List[Union[int, float]]] = []

        # Build up our classifications and training inputs
        for resistance, cadences in training_data.items():
            for cadence, power_speed_readings in cadences.items():
                for power_speed_reading in power_speed_readings:
                    power: int = power_speed_reading[0]
                    speed: float = power_speed_reading[1]

                    # Intended that predict(Cadence, Power, Speed) => Resistance
                    training_inputs.append([cadence, power, speed])
                    classifications.append(resistance)

        # Convert to np.array
        input_values: np.ndarray = np.array(training_inputs)
        output_values: np.ndarray = np.array(classifications)

        # Fit the data in the classifier
        self.logger.info(
            "Training (%d) data points to (%d) classifications", len(classifications), len(set(classifications))
        )
        self.classifier.fit(input_values, output_values)
        self.trained = True

    def predict_resistance(self, cadence: int, power: int, speed: float) -> int:
        """
        Predict Resistance based on Cadence, Power, and Speed

        :param int cadence: Cadence of bike (RPM)
        :param int power: Power being generated by bike (W)
        :param float speed: Speed of bike (mp/h)
        :return: Prediction resistance
        :rtype: int
        """
        if self.trained:
            # Convert input to np.array
            input_value: np.ndarray = np.array([[cadence, power, speed]])
            prediction: int = int(self.classifier.predict(input_value))

            return prediction
        return 0
